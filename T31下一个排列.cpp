/*
又是一道看题解才能做出来的题目，太失败了。
按照题解写下来，没有涉及到任何的算法和小tricks，感觉是纯粹看智商，然后我就写不来。。。
给定n个数，1~n，实际上字典的排列就是所构成的所有数字从小到大排列，如何找到恰好是自己下一位的数字串？
也就是要把当前数字变大，而且要是最小的变大。

其实变大的想法很直观，肯定是把后面的比较大的数字替换了前面的比较小的数字。
比如，12345，那更大的数字就是12354，12534......

但是问题在于，怎么恰好变大得到下一位，也就是所有变大选项里面最小的
同样要利用一个直观的想法就是：肯定要在比较低的位置做变换
比如12345，最低两位变化12354，影响就小；如果是15342，就大了很多了。

因此需要从后往前找相邻数对，找到第一个升序的数对，如果都是降序显然就没得换了。

那么找到第一个升序的数对，是交换这两个数字吗？显然不是
比如12543，倒数第一个升序数对是25，交换后是15243，但是显然比如13245就更贴近原数字12543。
因为当你找到nums[j-1] < nums[j]时，nums[j]~nums[end]都有可能大于nums[j-1]
为了得到更小的变大选项，我们肯定是用这里面最小的大于nums[j-1]的数字去换

又因为nums[j]~nums[end]是降序排列，我们从后往前找第一个比nums[j-1]大的数就行
然后交换这两者

这样就完事了吗？显然也不是
继续看12543，按照这个变化得到13542，我们可以发现13245显然更小

为什么这样得到呢？
因为实际上13...一定大于12...，所以最小的排列应该是13之后的数字升序排列

再把nums[j]~nums[end]升序排列一下就行
*/

class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        bool flag = false;  //假设是降序
        int index;
        for (int j = nums.size()-1; j >= 1; j--)
        {
            if(nums[j] > nums[j-1])
            {
                //升序
                flag = true;
                index = j;
                break;
            }
        }
        if(!flag)
        {
            //升序排列之后返回即可
            sort(nums.begin(), nums.end());
            return;
        }
        else
        {
            for (int k = nums.size()-1; k >= index; k--)
            {
                if(nums[k] > nums[index-1])
                {
                    //交换这二者
                    int temp = nums[k];
                    nums[k] = nums[index-1];
                    nums[index-1] = temp;
                    //index之后的降序排列重新排序一下
                    sort(nums.begin()+index, nums.end());
                    return;
                }
            }
        }
    }
};