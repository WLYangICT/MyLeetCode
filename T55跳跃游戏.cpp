/*
贪心的解法有时候真的会出乎我的意料的美妙。
这题是看了题解的，代码很简单，就着重通过自己的理解再讲一遍，看看是不是真的理解好了。

评论区有一句话“每个可达点的左侧所有点一定可达”
我们可以证明一下这句话：
    假如下标为k的点可达：
        如果是从k-1过来的，那么k-1可达
        如果是从k-x过来的，那么k-x一定可达，并且缩小步长就可以把[k-x, k]所有点可达
    总结就是，一个点可达的话，他和上一个可达点中间所有点都可达
    以此类推得到一个点可达，其左侧所有点均可达
    （其实有点像dp）

题解不是直接从这个结论出发的，但是有点这个意思
我们通过一个例子来讲解：nums = [2,3,1,1,4]
    首先，index=0，可达的范围就是[0, 0]
    nums[0]=2，说明最远可以走到2了，也就是[0, 2]均可达，目前最远的边界是2哦
    那么我们把index=1，index=2也走一遍，看看能不能走的更远，拓宽边界
    index=1时，可以走3，也就是最远可以走到4，说明[0, 4]均可达，最远边界是4
    index=2时，可以走1，最远走到3，在[0, 4]中，不更新边界
    
    实际上就是一次遍历nums，每次我们都计算该点可达的最远距离，和当前的边界比较
    如果小就不动，如果大就更新边界
    所以从0到边界的点始终可达

    如果某一次走到了边界之外的范围，也就是边界更新没有走的快了，那就说明不可达了

    如果最终所有点都走完了，说明最后一个点一定可达

这个想法真的非常非常巧妙！
*/
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int far = 0;
        for(int i = 0; i < nums.size(); i++)
        {
            if(i > far)
            {
                return false;
            }
            far = max(far, i+nums[i]);
        }
        return true;
    }
};